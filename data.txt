I do not fear computers. I fear lack of them.
A computer once beat me at chess, but it was no match for me at kick boxing.
Computer Science is no more about computers than astronomy is about telescopes.
The computer was born to solve problems that did not exist before.
Software is like entropy: It is difficult to grasp, weighs nothing, and obeys the Second Law of Thermodynamics; i.e., it always increases.
Software is a gas; it expands to fill its container.
All parts should go together without forcing.  You must remember that the parts you are reassembling were disassembled by you.  Therefore, if you can’t get them together again, there must be a reason.  By all means, do not use a hammer.
Standards are always out of date.  That’s what makes them standards.
Physics is the universe’s operating system.
It’s hardware that makes a machine fast.  It’s software that makes a fast machine slow.
Imagination is more important than knowledge.  For knowledge is limited, whereas imagination embraces the entire world, stimulating progress, giving birth to evolution.
The greatest enemy of knowledge is not ignorance, it is the illusion of knowledge.
The more you know, the more you realize you know nothing.
Tell me and I forget.  Teach me and I remember.  Involve me and I learn.
Real knowledge is to know the extent of one’s ignorance.
If people never did silly things, nothing intelligent would ever get done.
Getting information off the Internet is like taking a drink from a fire hydrant.
If you think your users are idiots, only idiots will use it.
From a programmer’s point of view, the user is a peripheral that types when you issue a read request.
Where is the ‘any’ key?
Computers are good at following instructions, but not at reading your mind.
There is only one problem with common sense; it’s not very common.
Your most unhappy customers are your greatest source of learning.
Let us change our traditional attitude to the construction of programs: Instead of imagining that our main task is to instruct a computer what to do, let us concentrate rather on explaining to human beings what we want a computer to do.
The Internet?  We are not interested in it.
The best way to get accurate information on Usenet is to post something wrong and wait for corrections.
The most likely way for the world to be destroyed, most experts agree, is by accident.  That’s where we come in; we’re computer professionals.  We cause accidents.
Pessimists, we’re told, look at a glass containing 50% air and 50% water and see it as half empty.  Optimists, in contrast, see it as half full.  Engineers, of course, understand the glass is twice as big as it needs to be.
In a room full of top software designers, if two agree on the same thing, that’s a majority.
It should be noted that no ethically-trained software engineer would ever consent to write a DestroyBaghdad procedure.  Basic professional ethics would instead require him to write a DestroyCity procedure, to which Baghdad could be given as a parameter.
Mostly, when you see programmers, they aren’t doing anything.  One of the attractive things about programmers is that you cannot tell whether or not they are working simply by looking at them.  Very often they’re sitting there seemingly drinking coffee and gossiping, or just staring into space.  What the programmer is trying to do is get a handle on all the individual and unrelated ideas that are scampering around in his head.
If you think you are worth what you know, you are very wrong.  Your knowledge today does not have much value beyond a couple of years.  Your value is what you can learn and how easily you can adapt to the changes this profession brings so often.
Programs must be written for people to read, and only incidentally for machines to execute.
Commenting your code is like cleaning your bathroom : you never want to do it, but it really does create a more pleasant experience for you and your guests.
We have to stop optimizing for programmers and start optimizing for users.
Low-level programming is good for the programmer’s soul.
It’s OK to figure out murder mysteries, but you shouldn’t need to figure out code.  You should be able to read it.
If we wish to count lines of code, we should not regard them as ‘lines produced’ but as ‘lines spent.’
Programming can be fun, so can cryptography; however they should not be combined.
Before software should be reusable, it should be usable.
If you automate a mess, you get an automated mess.
Looking at code you wrote more than two weeks ago is like looking at code you are seeing for the first time.
It is easier to change the specification to fit the program than vice versa.
Less than 10% of the code has to do with the ostensible purpose of the system; the rest deals with input-output, data validation, data structure maintenance, and other housekeeping.
If you have a procedure with ten parameters, you probably missed some.
How rare it is that maintaining someone else’s code is akin to entering a beautifully designed building, which you admire as you walk around and plan how to add a wing or do some redecorating. More often, maintaining someone else’s code is like being thrown headlong into a big pile of slimy, smelly garbage.
Code generation, like drinking alcohol, is good in moderation.
Simplicity, carried to the extreme, becomes elegance.
A program is never less than 90% complete, and never more than 95% complete.
When you are stuck in a traffic jam with a Porsche, all you do is burn more gas in idle.  Scalability is about building wider roads, not about building faster cars.
Everyone by now presumably knows about the danger of premature optimization.  I think we should be just as worried about premature design — designing too early what a program should do.
Programming without an overall architecture or design in mind is like exploring a cave with only a flashlight: You don’t know where you’ve been, you don’t know where you’re going, and you don’t know quite where you are.
The best way to predict the future is to implement it.
We need above all to know about changes; no one wants or needs to be reminded 16 hours a day that his shoes are on.
On two occasions I have been asked, ‘If you put into the machine wrong figures, will the right answers come out?’  I am not able rightly to apprehend the kind of confusion of ideas that could provoke such a question.
Make everything as simple as possible, but not simpler.
Today, most software exists, not to solve a problem, but to interface with other software.
Good specifications will always improve programmer productivity far better than any programming tool or technique.
The difference between theory and practice is that in theory, there is no difference between theory and practice.
Don’t document the problem, fix it.
As a rule, software systems do not work well until they have been used, and have failed repeatedly, in real applications.
If the code and the comments do not match, possibly both are incorrect.
I think it’s a new feature.  Don’t tell anyone it was an accident.
If you don’t handle exceptions, we shut your application down.  That dramatically increases the reliability of the system.
When debugging, novices insert corrective code; experts remove defective code.
In a software project team of 10, there are probably 3 people who produce enough defects to make them net negative producers.
I think it is inevitable that people program poorly.  Training will not substantially help matters.  We have to learn to live with it.
Program testing can be a very effective way to show the presence of bugs, but is hopelessly inadequate for showing their absence.
Manually managing blocks of memory in C is like juggling bars of soap in a prison shower: It’s all fun and games until you forget about one of them.
There’s no obfuscated Perl contest because it’s pointless.
Java is the most distressing thing to hit computing since MS-DOS.
There are only two things wrong with C++:  The initial concept and the implementation.
It was a joke, okay?  If we thought it would actually be used, we wouldn’t have written it!
Web Services are like teenage sex.  Everyone is talking about doing it, and those who are actually doing it are doing it badly.
Perl: The only language that looks the same before and after RSA encryption.
I didn’t work hard to make Ruby perfect for everyone, because you feel differently from me.  No language can be perfect for everyone.  I tried to make Ruby perfect for me, but maybe it’s not perfect for you.  The perfect language for Guido van Rossum is probably Python.
XML is not a language in the sense of a programming language any more than sketches on a napkin are a language.
BASIC is to computer programming as QWERTY is to typing.
It has been discovered that C++ provides a remarkable facility for concealing the trivial details of a program — such as where its bugs are.
UNIX is simple.  It just takes a genius to understand its simplicity.
Some people, when confronted with a problem, think ‘I know, I’ll use regular expressions.’  Now they have two problems.
I think computer viruses should count as life.  I think it says something about human nature that the only form of life we have created so far is purely destructive.  We’ve created life in our own image.
The only truly secure system is one that is powered off, cast in a block of concrete and sealed in a lead-lined room with armed guards.
Being able to break security doesn’t make you a hacker anymore than being able to hotwire cars makes you an automotive engineer.
Companies spend millions of dollars on firewalls, encryption and secure access devices, and it’s money wasted, because none of these measures address the weakest link in the security chain.
If you think technology can solve your security problems, then you don’t understand the problems and you don’t understand the technology.
Hoaxes use weaknesses in human behavior to ensure they are replicated and distributed.  In other words, hoaxes prey on the Human Operating System.
Passwords are like underwear: you don’t let people see it, you should change it very often, and you shouldn’t share it with strangers.
I am not out to destroy Microsoft, that would be a completely unintended side effect.
Yes, we have a dress code. You have to dress.
In an information economy, the most valuable company assets drive themselves home every night.  If they are not treated well, they do not return the next morning.
It’s better to wait for a productive programmer to become available than it is to wait for the first available programmer to become productive.
I’m not one of those who think Bill Gates is the devil.  I simply suspect that if Microsoft ever met up with the devil, it wouldn’t need an interpreter.
Two years from now, spam will be solved.
The problem of viruses is temporary and will be solved in two years.
Computer viruses are an urban legend.
In 2031, lawyers will be commonly a part of most development teams.
I don’t know what the language of the year 2000 will look like, but I know it will be called Fortran.
In the future, computers may weigh no more than 1.5 tonnes.
I see little commercial potential for the Internet for at least ten years.
Before man reaches the moon, mail will be delivered within hours from New York to California, to Britain, to India or Australia.
The best way to predict the future is to implement it.
Computers are good at following instructions, but not at reading your mind.
in a room where people think similar – not much thinking is done…
It’s hardware that makes a machine fast. It’s software that makes a fast machine slow.
Computers are useless.  They can only give you answers.
Computers are like bikinis. They save people a lot of guesswork.
They have computers, and they may have other weapons of mass destruction.
That’s what’s cool about working with computers.  They don’t argue, they remember everything, and they don’t drink all your beer.
If the automobile had followed the same development cycle as the computer, a Rolls-Royce would today cost $100, get a million miles per gallon, and explode once a year, killing everyone inside.
Computers are getting smarter all the time.  Scientists tell us that soon they will be able to talk to us.  (And by ‘they’, I mean ‘computers’.  I doubt scientists will ever be able to talk to us.)
I’ve noticed lately that the paranoid fear of computers becoming intelligent and taking over the world has almost entirely disappeared from the common culture.  Near as I can tell, this coincides with the release of MS-DOS.
The question of whether computers can think is like the question of whether submarines can swim.
It’s ridiculous to live 100 years and only be able to remember 30 million bytes.  You know, less than a compact disc.  The human condition is really becoming more obsolete every minute.
Never trust a computer you can’t throw out a window.
Hardware: The parts of a computer system that can be kicked.
Most software today is very much like an Egyptian pyramid with millions of bricks piled on top of each other, with no structural integrity, but just done by brute force and thousands of slaves.
I’ve finally learned what ‘upward compatible’ means.  It means we get to keep all our old mistakes.
There are two major products that come out of Berkeley: LSD and UNIX.  We don’t believe this to be a coincidence.
19 Jan 2038 at 3:14:07 AM
Every operating system out there is about equal… We all suck.
The Internet?  Is that thing still around?
The Web is like a dominatrix.  Everywhere I turn, I see little buttons ordering me to Submit.
Come to think of it, there are already a million monkeys on a million typewriters, and Usenet is nothing like Shakespeare.
The most amazing achievement of the computer software industry is its continuing cancellation of the steady and staggering gains made by the computer hardware industry.
True innovation often comes from the small startup who is lean enough to launch a market but lacks the heft to own it.
It has been said that the great scientific disciplines are examples of giants standing on the shoulders of other giants.  It has also been said that the software industry is an example of midgets standing on the toes of other midgets.
It is not about bits, bytes and protocols, but profits, losses and margins.
We are Microsoft.  Resistance Is Futile.  You Will Be Assimilated.
No matter how slick the demo is in rehearsal, when you do it in front of a live audience, the probability of a flawless presentation is inversely proportional to the number of people watching, raised to the power of the amount of money involved.
The bulk of all patents are crap.  Spending time reading them is stupid.  It’s up to the patent owner to do so, and to enforce them.
Controlling complexity is the essence of computer programming.
Complexity kills.  It sucks the life out of developers, it makes products difficult to plan, build and test, it introduces security challenges, and it causes end-user and administrator frustration.
There are two ways of constructing a software design.  One way is to make it so simple that there are obviously no deficiencies. And the other way is to make it so complicated that there are no obvious deficiencies.
The function of good software is to make the complex appear to be simple.
Just remember: you’re not a ‘dummy,’ no matter what those computer books claim.  The real dummies are the people who–though technically expert–couldn’t design hardware and software that’s usable by normal consumers if their lives depended upon it.
Software suppliers are trying to make their software packages more ‘user-friendly’…  Their best approach so far has been to take all the old brochures and stamp the words ‘user-friendly’ on the cover.
There’s an old story about the person who wished his computer were as easy to use as his telephone.  That wish has come true, since I no longer know how to use my telephone.
Any fool can use a computer.  Many do.
There are only two industries that refer to their customers as ‘users’.
Programmers are in a race with the Universe to create bigger and better idiot-proof programs, while the Universe is trying to create bigger and better idiots.  So far the Universe is winning.
Most of you are familiar with the virtues of a programmer.  There are three, of course: laziness, impatience, and hubris.
The trouble with programmers is that you can never tell what a programmer is doing until it’s too late.
That’s the thing about people who think they hate computers.  What they really hate is lousy programmers.
For a long time it puzzled me how something so expensive, so leading edge, could be so useless.  And then it occurred to me that a computer is a stupid machine with the ability to do incredibly smart things, while computer programmers are smart people with the ability to do incredibly stupid things.  They are, in short, a perfect match.
Computer science education cannot make anybody an expert programmer any more than studying brushes and pigment can make somebody an expert painter.
A programmer is a person who passes as an exacting expert on the basis of being able to turn out, after innumerable punching, an infinite series of incomprehensive answers calculated with micrometric precisions from vague assumptions based on debatable figures taken from inconclusive documents and carried out on instruments of problematical accuracy by persons of dubious reliability and questionable mentality for the avowed purpose of annoying and confounding a hopelessly defenseless department that was unfortunate enough to ask for the information in the first place.
A hacker on a roll may be able to produce–in a period of a few months–something that a small development group (say, 7-8 people) would have a hard time getting together over a year.  IBM used to report that certain programmers might be as much as 100 times as productive as other workers, or more.
The best programmers are not marginally better than merely good ones.  They are an order-of-magnitude better, measured by whatever standard: conceptual creativity, speed, ingenuity of design, or problem-solving ability.
A great lathe operator commands several times the wage of an average lathe operator, but a great writer of software code is worth 10,000 times the price of an average software writer.
Don’t worry if it doesn’t work right.  If everything did, you’d be out of a job.
Measuring programming progress by lines of code is like measuring aircraft building progress by weight.
Writing code has a place in the human hierarchy worth somewhere above grave robbing and beneath managing.
First learn computer science and all the theory.  Next develop a programming style.  Then forget all that and just hack.
First, solve the problem. Then, write the code.
Optimism is an occupational hazard of programming; feedback is the treatment.
To iterate is human, to recurse divine.
The best thing about a boolean is even if you are wrong, you are only off by a bit.
Should array indices start at 0 or 1?  My compromise of 0.5 was rejected without, I thought, proper consideration.
There are only two kinds of programming languages: those people always bitch about and those nobody uses.
PHP is a minor evil perpetrated and created by incompetent amateurs, whereas Perl is a great and insidious evil perpetrated by skilled but perverted professionals.
The use of COBOL cripples the mind; its teaching should therefore be regarded as a criminal offense.
It is practically impossible to teach good programming style to students that have had prior exposure to BASIC.  As potential programmers, they are mentally mutilated beyond hope of regeneration.
I think Microsoft named .Net so it wouldn’t show up in a Unix directory listing.
There is no programming language–no matter how structured–that will prevent programmers from making bad programs.
Computer language design is just like a stroll in the park.  Jurassic Park, that is.
Fifty years of programming language research, and we end up with C++?
Writing in C or C++ is like running a chain saw with all the safety guards removed.
In C++ it’s harder to shoot yourself in the foot, but when you do, you blow off your whole leg.
C++ : Where friends have access to your private members.
One of the main causes of the fall of the Roman Empire was that–lacking zero–they had no way to indicate successful termination of their C programs.
Java is, in many ways, C++–.
Saying that Java is nice because it works on all OSes is like saying that anal sex is nice because it works on all genders.
Fine, Java MIGHT be a good example of what a programming language should be like.  But Java applications are good examples of what applications SHOULDN’T be like.
If Java had true garbage collection, most programs would delete themselves upon execution.
Software is like sex: It’s better when it’s free.
The only people who have anything to fear from free software are those whose products are worth even less.
Good code is its own best documentation.
Any code of your own that you haven’t looked at for six or more months might as well have been written by someone else.
The first 90% of the code accounts for the first 90% of the development time.  The remaining 10% of the code accounts for the other 90% of the development time.
Good programmers use their brains, but good guidelines save us having to think out every case.
In software, we rarely have meaningful requirements.  Even if we do, the only measure of success that matters is whether our solution solves the customer’s shifting idea of what their problem is.
Considering the current sad state of our computer programs, software development is clearly still a black art, and cannot yet be called an engineering discipline.
You can’t have great software without a great team, and most software teams behave like dysfunctional families.
As soon as we started programming, we found to our surprise that it wasn’t as easy to get programs right as we had thought.  Debugging had to be discovered.  I can remember the exact instant when I realized that a large part of my life from then on was going to be spent in finding mistakes in my own programs.
Debugging is twice as hard as writing the code in the first place.  Therefore, if you write the code as cleverly as possible, you are–by definition–not smart enough to debug it.
If debugging is the process of removing bugs, then programming must be the process of putting them in.
I don’t care if it works on your machine!  We are not shipping your machine!
Programming is like sex: one mistake and you’re providing support for a lifetime.
There are two ways to write error-free programs; only the third one works.
You can either have software quality or you can have pointer arithmetic, but you cannot have both at the same time.
Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live.
To err is human, but to really foul things up you need a computer.
A computer lets you make more mistakes faster than any invention in human history–with the possible exceptions of handguns and tequila.
Everything that can be invented has been invented.
I think there’s a world market for about 5 computers.
It would appear that we have reached the limits of what it is possible to achieve with computer technology, although one should be careful with such statements, as they tend to sound pretty silly in 5 years.
But what is it good for?
There is no reason for any individual to have a computer in his home.
640K ought to be enough for anybody.
Windows NT addresses 2 Gigabytes of RAM, which is more than any application will ever need.
We will never become a truly paper-less society until the Palm Pilot folks come out with WipeMe 1.0.
If it keeps up, man will atrophy all his limbs but the push-button finger.
There are so many men who can figure costs, and so few who can measure values.
A corporation is a living organism; it has to continue to shed its skin.  Methods have to change.  Focus has to change.  Values have to change.  The sum total of those changes is transformation.
The most dangerous kind of waste is the waste we do not recognize.
Your lean process should be a lean process.
There is nothing so useless as doing efficiently that which should not be done at all.
Continuous improvement is not about the things you do well - that's work.  Continuous improvement is about removing the things that get in the way of your work.  The headaches, the things that slow you down, that’s what continuous improvement is all about.
If you need a new process and don't install it, you pay for it without getting it.
Everything can be improved.
Willful waste brings woeful want.
There are many experts on how things have been done up to now. If you think something could use a little improvement, you are the expert.
Amateurs work until they get it right.  Professionals work until they can't get it wrong.
It is not the employer who pays the wages.  He only handles the money.  It is the product that pays the wages.
Nature does constant value stream mapping - it's called evolution.
Don't waste time learning the "tricks of the trade."  Instead, learn the trade.
Time waste differs from material waste in that there can be no salvage.  The easiest of all wastes and the hardest to correct is the waste of time, because wasted time does not litter the floor like wasted material.
Waste is a tax on the whole people.
When solving problems, dig at the roots instead of just hacking at the leaves.
A bad system will beat a good person every time.
It is an immutable law in business that words are words, explanations are explanations, promises are promises but only performance is reality.
We are too busy mopping the floor to turn off the faucet.
Watch the little things; a small leak will sink a great ship.
Waste is worse than loss.  The time is coming when every person who lays claim to ability will keep the question of waste before him constantly.  The scope of thrift is limitless.
It is more than probable that the average man could, with no injury to his health, increase his efficiency fifty percent.
The essential question is not, "How busy are you?" but "What are you busy at?"
A relentless barrage of "why’s" is the best way to à your mind to pierce the clouded veil of thinking caused by the status quo.  Use it often.
The first rule of any technology used in a business is that automation applied to an efficient operation will magnify the efficiency.  The second is that automation applied to an inefficient operation will magnify the inefficiency.
The world we have created is a product of our thinking; it cannot be changed without changing our thinking.
If you don't know where you are going, you will probably end up somewhere else.
Improvement usually means doing something that we have never done before.
Work expands so as to fill the time available for its completion.
On the bathing-tub of King T'ang the following words were engraved:  "If you would one day renovate yourself, do so from day to day.  Yea, let there be daily renovation."
An environment where people have to think brings with it wisdom, and this wisdom brings with it kaizen continuous improvement.
The impossible is often the untried.
The man who will use his skill and constructive imagination to see how much he can give for a dollar, instead of how little he can give for a dollar, is bound to succeed.
If you don't have time to do it right you must have time to do it over.
Ford's success has startled the country, almost the world, financially, industrially, mechanically.  It exhibits in higher degree than most persons would have thought possible the seemingly contradictory requirements of true efficiency, which are:  constant increase of quality, great increase of pay to the workers, repeated reduction in cost to the consumer.  And with these appears, as at once cause and effect, an absolutely incredible enlargement of output reaching something like one hundredfold in less than ten years, and an enormous profit to the manufacturer.
Great ideas need landing gear as well as wings.
Different isn't always better, but better is always different.
He who rejects change is the architect of decay.  The only human institution which rejects progress is the cemetery.
Invest a few moments in thinking.  It will pay good interest.
Don't water your weeds.
You must have long-range goals to keep you from being frustrated by short-range failures.
I don't like a man to be too efficient.  He's likely to be not human enough.
If all efficiency experts were laid end to end - I'd be in favor of it.
One half of knowing what you want is knowing what you must give up before you get it.
I shall try to correct errors when shown to be errors, and I shall adopt new views so fast as they appear to be true views.
It is better to stir up a question without deciding it, than to decide it without stirring it up.
Quality is everyone's responsibility.
It is not enough to do your best; you must know what to do, and then do your best.
Profit in business comes from repeat customers, customers that boast about your project or service, and that bring friends with them.
If you can't describe what you are doing as a process, you don't know what you're doing.
You can not inspect quality into the product; it is already there.
It does not happen all at once. There is no instant pudding.
If you stay in this world, you will never learn another one.
Does experience help? NO! Not if we are doing the wrong things.
The result of long-term relationships is better and better quality, and lower and lower costs.
We are here to make another world.
Don’t be afraid to make mistakes.
If you’re 60 percent sure, take action.
Before you say you can’t do something, try it.
I have seen more failures than successes.
To do what you believe is right, to do what you believe is good, and doing these things right then and in that way is a calling from on high.  Thus, do it boldly, do as you believe, do as you are.
Each person thoroughly fulfilling their duties generates great power that, gathered together in a chain, creates a ring of power.
Since it’s the customer that pays our salary, our responsibility is to make the product they want, when they want it, and deliver quality that satisfies them.
There’s got to be a better way
Reform business when business is good.
No change is bad
Action at the Source
Let’s give it a try.
Don’t be afraid to make mistakes.
Simplicity is the ultimate sophistication
Simplicity does not precede complexity, but follows it
Productivity is being able to do things that you were never able to do before
Innovation is the process of turning ideas into manufacturable and marketable form.
Creativity is thinking up new things. Innovation is doing new things.
Never before in history has innovation offered promise of so much to so many in so short a time.
Great innovations should not be forced on slender majorities.
Innovation by definition will not be accepted at first. It takes repeated attempts, endless demonstrations, monotonous rehearsals before innovation can be accepted and internalized by an organization. This requires 'courageous patience'.
Fashion is something barbarous, for it produces innovation without reason and imitation without benefit.
You have all the reason in the world to achieve your grandest dreams. Imagination plus innovation equals realization.
Entrepreneurs innovate. Innovation is the specific instrument of entrepreneurship. It is the act that endows resources with a new capacity to create wealth.
The world leaders in innovation and creativity will also be world leaders in everything else.
Innovation is not the product of logical thought, although the result is tied to logical structure.
I didn't know it was impossible when I did it
He who moves not forward, goes backward.
All that is human must retrograde if it does not advance.
No snowflake in an avalanche ever feels responsible." Voltaire

I try. I fail. I try again. I fail better.
Experience is not what happens to a man; it is what a man does with what happens to him.
Take care of the large problems and the small ones will tend not to bother you.
Computers are useless. They can only give you answers." - Pablo Picasso
Nobody is perfect, but a team can be" - Meredith Belbin
Necessity is the mother of invention" - Plato
Learn from yesterday, live for today, hope for tomorrow. The important thing is not to stop questioning.
We cannot solve our problems with the same thinking we used when we created them.
If you can't explain it simply, you don't understand it well enough.
Anyone who has never made a mistake has never tried anything new.
The only source of knowledge is experience.
Make everything as simple as possible, but not simpler.
Information is not knowledge.
I have not failed. I've just found 10,000 ways that won't work.
Genius is one percent inspiration and ninety-nine percent perspiration.
All algorithms are O(f(n)), where f is someone else’s responsibility.
48% of IE7 usage comes from developers checking that their site works in IE7.
Programmers don’t burn out on hard work, they burn out on change-with-the-wind directives and not ‘shipping’.
I’ve known people who have not mastered their tools who are good programmers, but not a tool master who remained a mediocre programmer.
There are two types of people in this world: those who understand recursion and those who don’t understand that there are two types of people in this world.
Software developers like to solve problems. If there are no problems handily available, they will create their own problems.
The problem with quick and dirty, is that the dirty remains long after the quick has been forgotten
Prolific developers don’t always write a lot of code, instead they solve a lot of problems. The two things are not the same.
A programmer’s wife tells him: go to store. pick up a loaf of bread. If they have eggs, get a dozen. The programmer returns with 12 loaves.
Bad programmers have all the answers. Good testers have all the questions.
Our job is to tell you your baby is ugly!
The best TDD can do, is assure that code does what the programmer thinks it should do. That is pretty good BTW.
The bitterness of poor quality remains long after the sweetness of meeting the schedule has been forgotten.
One bad programmer can easily create two new jobs a year.
Don’t document bad code — rewrite it.
3 Errors walk into a bar. The barman says, normally I’d Throw you all out, but tonight I’ll make an Exception.
Weeks of programming can save you hours of planning.
If you think it’s expensive to hire a professional, wait until you hire an amateur.
Programming can be fun, so can cryptography; however they should not be combined.
The proper use of comments is to compensate for our failure to express ourself in code.
My definition of an expert in any field is a person who knows enough about what’s really going on to be scared.
First, solve the problem. Then, write the code.
Programming is not a zero-sum game. Teaching something to a fellow programmer doesn’t take it away from you.
One of my most productive days was throwing away 1000 lines of code
When in doubt, use brute force.
Deleted code is debugged code.
Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it. — Brian W. Kernighan and P. J. Plauger in The Elements of Programming Style.
The most effective debugging tool is still careful thought, coupled with judiciously placed print statements.
Controlling complexity is the essence of computer programming.
Beauty is more important in computing than anywhere else in technology because software is so complicated. Beauty is the ultimate defence against complexity.
UNIX was not designed to stop its users from doing stupid things, as that would also stop them from doing clever things.
Life is too short to run proprietary software.
The central enemy of reliability is complexity.
Simplicity is prerequisite for reliability.
Simplicity is the ultimate sophistication.
The unavoidable price of reliability is simplicity.
You can’t trust code that you did not totally create yourself.
Compatibility means deliberately repeating other people’s mistakes.
Debugging time increases as a square of the program’s size.
The best code is no code at all.
Program testing can be a very effective way to show the presence of bugs, but is hopelessly inadequate for showing their absence.
Code never lies, comments sometimes do.
If we’d asked the customers what they wanted, they would have said faster horses
With diligence it is possible to make anything run slowly.
Software obeys the law of gaseous expansion – it continues to grow until memory is completely filled.
A distributed system is one in which the failure of a computer you didn’t even know existed can render your own computer unusable.
The proper use of comments is to compensate for our failure to express ourself in code.
Incorrect documentation is often worse than no documentation.
Security is a state of mind.
And don’t EVER make the mistake that you can design something better than what you get from ruthless massively parallel trial-and-error with a feedback cycle. That’s giving your intelligence much too much credit
We don’t get a chance to do that many things, and every one should be really
excellent. Because this is our life. And we’ve all chosen to do this with our
lives. So it better be damn good. It better be worth it.
People think focus means saying yes to the thing you’ve got to focus on. But
that’s not what it means at all. It means saying no to the hundred other good
ideas that there are. You have to pick carefully.
If there is no solution, then there is no problem.
There is no scientific method.
I made a discovery today. I found a computer.
Wait a second, this is cool. It does what I want it to.
If it makes a mistake, it's because I screwed it up.
Not because it doesn't like me...
Or feels threatened by me...
Or thinks I'm a smart ass...
Or doesn't like teaching and shouldn't be here...
Damn kid. All he does is play games. They're all alike.
It is better to be technically elegant with a higher learning curve, than to
be easy to use, and technically crap. Layers of abstraction that serve to hide
internals are never a good thing. Instead, the internals should be designed in
a way such that they NEED no hiding.
When in doubt, use brute force.
Simplicity is prerequisite for reliability.
Beauty is more important in computing than anywhere else in technology because
software is so complicated. Beauty is the ultimate defence against complexity.
Programming is not a zero-sum game. Teaching something to a fellow programmer
doesn't take it away from you. I'm happy to share what I can, because I'm in it
for the love of programming.
In my opinion, perfection is not reached when there is nothing left to
add but when there is nothing left to remove. That means the perfection
of a thing and its essence are a single reality. But here is the real
challenge: how do you get to the essence of things?
The so-called "desktop metaphor" of today's workstation is instead an
"airplane-seat" metaphor. Anyone who has shuffled a lap full of papers
while seated between two portly passengers will recognize the
difference--one can see only a very few things at once.
The building metaphor has outlived its usefulness.  Let us turn
nature and study complexity in living things.  The secret is that
it is grown, not built.
You can be productive or safe, not both.
Eventually it all comes to this: expect nothing, get involved!
Nine people can't make a baby in a month.
The best way to predict the future is to invent it.
Lua is the C of dynamic languages: lean, fast - and real men write their
own libraries.
Artists work best alone. Work alone.
Predicting the future of the Internet is easy: anything it hasn’t yet
dramatically transformed, it will.  People, companies, investors and
even countries can’t stop this transformation. The only choice you have
is whether you join the side of innovation and progress or you don’t.
The worst features of a language are the attractive nuisances, the
features that are both useful and dangerous.
The problem with being a beginner is that you get a lot of practice
staying a beginner.
You can be an engineer and become a manager and get rich, or you can be
an engineer and stay an engineer and get rich.
A true friend will stab you in the front.
Bottomless wonders come from simple rules repeated without end.
Bad programmers worry about the code. Good programmers worry about data
structures and their relationships.
Nobody should start to undertake a large project. You start with a small
trivial project, and you should never expect it to get large. If you do,
you'll just overdesign.
Some specious value of "correctness" is often irrelevant because it
doesn't matter. While performance almost always matters.
There really are only two acceptable models of development: "think and
analyze" or "years and years of testing on thousands of machines". Those
two really do work.
There is one quality that cannot be purchased in this way, and that is
reliability. The price of reliability is the pursuit of the utmost
simplicity. It is a price which the very rich find most hard to pay.
Debugging time increases as a square of the program's size.
Code never lies, comments sometimes do.
Software sucks because users demand it to.
The only sin is to make a choice without knowing you are making one.
One of the big lessons of a big project is you don't want people that
aren't really programmers programming, you'll suffer for it!
Everything should be built top-down, except the first time.
Optimization hinders evolution.
Everyone can be taught to sculpt: Michelangelo would have had to be
taught how not to. So it is with the great programmers.
Fools ignore complexity. Pragmatists suffer it. Some can avoid it.
Geniuses remove it.
A year spent in artificial intelligence is enough to make one believe in
God.
When someone says "I want a programming language in which I need only
say what I wish done," give him a lollipop.
Dealing with failure is easy: Work hard to improve. Success is also easy
to handle: You've solved the wrong problem. Work hard to improve.
It goes against the grain of modern education to teach children to
program. What fun is there in making plans, acquiring discipline in
organizing thoughts, devoting attention to detail and learning to be
self-critical?
In seeking the unattainable, simplicity only gets in the way.
Premature optimization is the root of all evil.
Premature generalization is the other root of all evil.
Written by a C++ developer with Stockholm Syndrome: "Complex programming
problems require complex languages."
The good thing about reinventing the wheel is that you can get a round
one.
Probably my job description would be just to find something to make life
better. Or have some new idea of new stuff that replaces old stuff. Try
to make it better. Whatever it is that's wrong, that takes time, that
causes bugs.
C++ does a lot of things half well and it's just a garbage heap of
ideas that are mutually exclusive.
I have determined that the complexity class of most C++ programs is
NP-Fucked.
Give a man a fish, feed him for a day. Teach a man to fish, and you'll
have to answer fucking fish questions the rest of your life.
It's funny, but I used to get really pissed off at Larry Wall for
calling Java programmers "babies". It turns out the situation is a
little more complicated than that... but only a little.
I am very interested in obsoleting GNU bloatware: it's crap. From a
purely technical perspective, the FSF _sucks_at_writing_code_. They're
horrible, and their stuff should die. That's why I got into BusyBox in
the first place: I want GNU-less Linux.
Sometimes, the elegant implementation is just a function. Not a method.
Not a class. Not a framework. Just a function.
Java is like a variant of the game of Tetris in which none of the pieces
can fill gaps created by the other pieces, so all you can do is pile
them up endlessly.
I have discovered that there are two types of command interfaces in the
world of computing: good interfaces and user interfaces. The essence of
user interfaces is parsing: converting an unstructured sequence of
commands, in a format usually determined more by psychology than by
solid engineering, into structured data.  This situation is a
recipe for disaster.
The Internet isn't really a technology, it's a belief system - a
philosophy.  The belief system of the Internet is that everyone
should have the freedom to connect, the freedom to innovate and the
freedom to hack without asking permission. No one can know the whole of
it; it cannot be centrally controlled and the innovation happens in
small groups on the "edges" of the network.
It is now usually cheaper to just try something than to sit around and
try to figure out whether to try something.  The compass has
replaced the map and the idea of "rough consensus running code" has
spread from the ideology behind network architecture to a fundamental
philosophy for startup companies and the "lean startup" movement.
Hobbyists are the ones who invent new stuff, almost exclusively.  A
thousand professional physicists picked at random probably wouldn't
fundamentally change physics the way Albert Einstein did as a hobby
while working as a patent clerk. Hobbyists are artists as much as
engineers. They get writer's block. They have portfolio pieces showing
cool things they've done, which are generally more interesting than
their resume listing experience and training. Hobbyists go off on
tangents ALL THE TIME, that's how they come up with new stuff nobody's
ever done before, with sturgeon's law in full force: 90% of that new
stuff is crap, but a tiny fraction of it is spectacular. A
hobbyist generally responds to "What's it good for?" with "Let's find
out!".
In the physical world, an engineer’s job is to build a project to spec.
But in the world of software, sometimes it’s the case that you start
building a bridge, then halfway through realize what you really need is
a boat. As developers, we can make that switch because software is,
well, soft.
It's too easy to fall out of touch with the code when you're managing a
product from a higher level. When you don't understand the code, you
won't understand why a change takes as long as it does, or how to
increase the speed of change. The code affects long term flexibility
too. If the code is hard to change, a feature will be hard to change.
That's a product level issue.
People who don’t take risks generally make about two big mistakes a
year. People who do take risks generally make about two big mistakes a
year.
It is nice to know the dictionary definition for the adjective elegant
is the meaning simple and surprisingly effective.
Simplicity is a great virtue but it requires hard work to achieve it and
education to appreciate it. And to make matters worse: complexity sells
better. The computing industry is not the only one that has discovered
that sore truth: so has the academic world. If you deliver a lecture
that is crystal clear from the beginning to end, your audience feels
cheated and mutters while leaving the lecture hall "That was all rather
trivial, wasn't it?". One of our learned journals has rejected a
beautiful paper of mine because the solution it presented was too simple
to be of academic interest and I am waiting for the rejection of a paper
on the grounds that it is too short.
He is someone extraordinarily gifted, able to tackle any mathematical or
even scientific problem, and most people with these qualities tend not
to focus. Gérard Berry, schockingly, kept focused on his research topic
(synchronous systems) from the day he knew that was it. It was not easy
at first, nobody took him seriously.
The art of programming is the skill of controlling complexity.
Everyone has a plan 'till they get punched in the mouth.
I dislike "flag" arguments that are intended to change the behavior of a
method in some big way. The call would be more readable if the API
had separate methods: one for each flag value.
Entreprise-friendly is usually when the really smart people lose
interest and the people of more mediocre skills have to somehow fend for
themselves.
There is no contemporary problems requiring millions of lines of code.
Instead there are careless programmers, bad managers, or impossible
requirements for compatibility.
I'm amazed that software written in the 1970s hasn't/can't be rewritten.
One reason might be that in those days software was exciting; things
being done for the first time; programmers working 18-hour days for the
joy of it. Now programming is a 9-5 job as part of a team working to a
schedule; not much fun.
Lisp did not address I/O. In fact, C did not address I/O and because it
didn't, it needed an operating system. Forth addressed I/O from the very
beginning.
The critical skill grad students have to master is noticing something so
obvious that no one else has noticed it before.
I think the root of your mistake is saying that macros don't scale to
larger groups. The real truth is that macros don't scale to stupider
groups.
Two ranchers, a Canadian and an American, meet at a Cattle Convention.
The American boasts “My ranch is so big, I can git’ in my truck and
drive for a day in any direction, and I’m still on ma’ propuh-ty.”
The Canadian nods in sympathy. “I used to have a truck just like that.”
Avoid OO whenever possible. Contrary to common belief, most problems are
better solved in non-OO ways.
Some people, when confronted with a reliability problem, think, “I know,
I’ll build a distributed system.” Now they have n² problems.
Simplicity is often in tension with convenience. Convenience often wins
in the short term, but simplicity always wins in the long term. The real
trick is finding a way to get both simplicity and convenience. That is
the secret sauce and it’s SO worth the effort.
Python is not a functional language dfor a very good reason: Python is
very pragmatic. It lets you mess around with state, fiddle with the
OS... All kinds of things that you can very easily do in Python, but
somehow are incredibly hard in a beautiful language like Haskell.
My opinion is that OOP is one of the great frauds perpetrated on the
community.
I'd say Kernighan emphasized ease of learning; Weinberger, soundness of
implementation; and I, utility.
It's not much of an exaggeration to say that as a programmer either I am
trying to decide what to do next, or I am debugging. Everything else
takes hardly any time.
The best path to high-quality software is talented experts who share a
pretty clear sense of what they want to produce. I have no idea how to
produce good software without talented programmers.
I usually consider that if something needs comments, it is not well
written. For me, a comment is almost a note like "I should try to
rewrite this code later." I think clear code is much more readable than
commented code.
Design for minimal resources, and you may be pleasantly surprised to see
your tool used in many contexts that you did not have as a primary goal
and some that you did not even know existed. When we discuss the
inclusion of a feature in Lua, we ask ourselves: "OK, but will it run in
a microwave oven?"
The effect of individual differences will far outweigh any effect of the
programming language on productivity.
If I revisited Objective-C today, I might even go as far as to remove
inheritance. Inheritance just isn't all that important. Encapsulation
is OOP's lasting contribution.
I'm focused on SOA and JBI today. They support encapsulation as much as
traditional OOP. Even better; they encapsulate not just data +
procedures, but even the entire thread of control that powers them.
The big change was ubiquitous networking, which opened up new levels of
integration larger than the Unix process space. In SOA for example, the
Internet is like the cabling between the components of a HiFi system,
with services on disparate servers functioning like the components
themselves.
We had exactly the problem gate-level designers face when designing
big chips. Their solution? Encapsulate a bunch of gates inside a chip.
I'll handle chip design. You solder them together. Objective-C was
precisely that notion. Of course  languages are tools, things to be
picked up or laid aside according to the problem at hand.
It's all about doing more with less. It's not about doing more with more
with a simple layer on top.
Unfortunately, RUP became understood as a prescriptive methodology like
cooking food. None of us who have developed software would even dream
that you really do it step by step, following a checklist.
The industry is very immature. It's a little more mature than it was 20
years ago, but we build much more complex systems today.
Unfortunately, a lot of people who were jealous of our initial success
got involved in the second version. They felt they could have done just
as well as we did. As things turned out, they couldn't.  So UML 2.0
became a bloated monstruosity.  It shows the limitations of trying
to do creative activity by commitee.
The sad thing is that most of the problems Brooks cites in The
Mythical Man-Month are still happening today.  Maybe this is a
good way to state the main problem facing the computing field: most of
its practitioners have no understanding of computing history and so
 they are condemned to repeat the same mistakes.
I think using UML to generate implementation code is a terrible idea.
 If you can generate code from a model, then it is a programming
language. And UML is not a well-designed programming language.
Don't believe the nonsense about inventing a better mousetrap: it takes
serious marketing to get something adopted.
Computers really don't understand when they should ask for feedback.
That's because they don't understand when they should be unsure.
When OOP came onto the scene and most people said it is what comes after
structured methods, to me that made no sense. It was part of structured
methods right from the beginning. Structured programming was for
programming-in-the-small aspects, and OOP was for
programming-in-the-large, but there was no gap between the two. Having
read Dahl's and Hoare's text, I knew this was the right way to program.
I have never seen a breakthrough product in software that was built by
more than 10 people, and usually it is somewhere between 2 and 5.
Nowadays, most of the code written has an inheritance structure, which
is encouraged in the hope that it will bring clarity to the code.
However this is not beautiful code; it is bad code with a
convoluted design. If you cannot tell what the code does by glancing at
the naming conventions and several code lines, then the code is too
complicated.
Bill Gosper once said: "Data is just a dumb kind of programming." The
corollary, of course, is that code is just a smart kind of data, data
designed to trigger processors into performing certain useful or amusing
acts.
Is the lack of runtime type checking good enough to be called
"beautiful code"? After working with it for over five years, yes, I
think it is. It keeps easy hacks from springing up within the kernel and
forces everyone to be very exact in their logic, never falling back on
any checks for types that might prevent bugs from happening later.
Any problem in computer science can be solved with another layer of
indirection, but that usually will create another problem.
Unix is an operating system designed primarily for technical users
that know better than OS designers what their own needs are.
The Unix philosophy is bottom-up, not top down. It is pragmatic and
grounded in experience. It is not to be found in official methods and
standards, but rather in the implicit hard-reflexive knowledge, the
expertise that the Unix culture transmits.
Controlling complexity is the essence of computer programming.
The only way to write complex software that won't fall on its face is to
hold its global complexity down, to build it out of simple parts
connected by well-defined interfaces, so that most problems are local
and you can have some hope of upgrading a part without breaking the
whole.
Hardwiring policy and mechanism together has two bad effects: it makes
policy rigid and harder to change in response to user requirements, and
it means that trying to change policy has a strong tendency to
destabilize the mechanisms.
The original HTML documents recommend "be generous in what you accept",
and it has bedeviled us ever since because each browser accepts a
different superset of the specifications. It is the specifications that
should be generous, not their interpretation.
Make it run, then make it right, then make it fast.
Rushing to optimize before the bottlenecks are known may be the only
error to have ruined more designs than feature creep.
I remember one development manager at Bellcore who fought against the
"requirements" culture years before anybody talked about "rapid prototyping" or "agile development". He wouldn't issue long
specifications; he'd lash together some combination of shell scripts and
awk code that did roughly what was needed, have the customers
tell him whether or not they liked it. If they did, he would say "you
can have it industrial strength so-many-months from now at such-and-such
cost". His estimates tended to be accurate, but he lost out in the
culture to managers who believed that requirements writers should be in
control of everything.
The Unix tradition includes a healthy distrust of "one true way"
approaches to software design or implementation. It embraces multiple
languages, open extensible systems, and customization hooks everywhere.
When you see the right thing, do it. This may look like more work in the
short term, but it's the path of least effort in the long run. If you
don't know what the right thing is, do the minimum necessary to get the
job done, at least until you figure out what the right thing is.
Later, PDP-10 hackers became the founding cadre of the IETF and
originated the tradition of standardization through RFCs. Socially, they
were young, exceptionally bright, almost entirely male, dedicated to the
point of addiction, and tended to have streaks of stubborn
nonconformism. They had a vision of computers as community-building
devices.
The pipe was technically trivial, but profound in its effect. However,
it would not have been trivial without the fundamental unifying notion
of the process as an autonomous unit of computation, with process
control being programmable.
The day Linux gives the Mac diagnostic that you can't open a file
because you don't have the application is the day Linux becones
non-Unix.
There are two ways of constructing a software design. One is to make it
so simple that there are obviously no deficiencies; the other is to make
it so complicated that there are no obvious deficiencies. The first
method is far more difficult.
Doug McIlroy's advice to "do one thing well" is usually interpreted as
being about simplicity. But it is also, implicitly and at least as
importantly, about orthogonality.
One single bug-prone glue layer is not the worst fate that can befall a
design. A designer who is aware that the glue layer exists, and tries to
organize it into a middle layer around its own set of data structures or
objects, can end up with *two* levels of glue: one above the midlayer
and one below.
All OO languages show some tendency to suck programmers into the trap of
excessive layering.
There is more vocal criticism of OO in the Unix world than orthodoxy
permits elsewhere; Unix programmers know when *not* to use OO; and when
they do use OO languages, they spend more effort trying to keep their
object designs uncluttered.
Commercial Unix distributions that have suppressed the BUGS section or
euphemized it have invariably fallen into decline.
Using the Unix file system as a database is a tactic other applications
with simple database requirements might do well to emulate. Good reasons
not to do it are more likely to have to do with the database keys not
naturally looking like filenames than they are with any performance
problems.
If you want transparent code, the most effective route is simply not to
layer too much abstraction over what you are manipulating with the code.
If we believe in data structures, we must believe in independent (hence
simultaneous) processing. For why else would we collect items within a
structure? Why do we tolerate languages that give us the one without the
other?
Threading is a performance hack. They do not reduce global complexity
but rather increase it, and should therefore be avoided save under dire
necessity.
If you can use limited shared memory and semaphores, asynchronous I/O
using SIGIO or poll/select rather than threading, do it that way.
The Unix tradition of program interface design has an inner logic to
it which is worth learning and understanding. It reflects heuristics
accumulated over Unix's long history about ways to do effective
communication both with human beings and with other programs.
Consider your tradeoffs carefully, and consider them from the user's
point of view. The bias implied by the Rule of Least Surprise is a good
one to hold consciously, mainly because interface designers have an
unconscious tendency to be too clever for the user's good.
The design of consumer software since 1984 has become heavily skewed
toward GUIs. While this is a good choice for novice and casual users
that constitute most of the market, it also exacts hidden costs on more
expert users.
Programs should request confirmation only when there is good reason to
suspect that the answer might be "no no no!"
Reading profiler results is something of an art. There are a couple
(sic) of recurring problems: one is instrumentation noise, another is
the effect of imposed external latencies, and a third is overweighting
of upper nodes in the call graph.
The MIT and New Jersey philosophies have analogs within the Unix design
tradition itself. One strain of Unix thinking emphasizes small sharp
tools, starting designs from zero and interfaces that are simple and
consistent. This point of view has been most famously championed by Doug
McIlroy. Another strain emphasizes doing simple implementations that
work and that ship quickly, even if the methods are brute-force and some
edge cases have been punted. Ken Thompson's code and his maxims about
programming have often seemed to lean in this direction. The tension
between these approaches arises precisely because one can sometimes get
a simpler interface if one is willing to pay implementation complexity
for it, or vice versa.
You can cut accidental complexity by noticing that there is a simpler
way to do things. You can cut optional complexity by making
context-dependent judgements about what features are worthwhile. You can
only cut essential complexity by having an epiphany, fundamentally
redefining the problem you are addressing.
-- Eric S. Raymond

The reason that vi and emacs never caught on among old-school Unix
programmers is that they are *ugly*. This complaint may be "old Unix"
speaking, but had it not been for the singular taste of old Unix, "new
Unix" would not exist.
My ideal for the future is to develop a filesystem remote interface (a
la Plan 9) and then have it implemented across the Internet as the
standard rather than HTML. The would be ultimate cool.
This is why you spent all that time learning to program: you can fix
things. You can make new and amazing things. Don't take that ability
lightly.
In many ways, the end result is unimportant – it’s really just the
excuse for the whole experience. It’s why I started Linux to begin with
– sure, I kind of needed an OS, but I needed a *project* to work on more
than I needed the OS.  My model is kind of a reverse “end result
justifies the means”. Hell no, that’s the stupidest saying in the
history of man.  It’s simply not the end that matters at all. It’s
the means – the journey. The end result is almost meaningless.
I've never found the idea of depending on a huge C++ library
particularly attractive for my projects. Admittedly, I _do_ have an
aversion to 'enterprise-level' programming.
I do not fear computers. I fear the lack of them.
A complex system that works is invariably found to have evolved from a
simple system that worked.
I think I've been able to reach my goals on the internet better than
most people. The fact that I'm very clear about my opinions is probably
part of it. I hate that whole "victim philosophy". The truth shouldn't
be sugarcoated.
For those of you who think we have been engaged in steady progress, in
some form of Darwinian process that are making things better for us,
it's actually quite the opposite.
Technology happens, it's not good, it's not bad. Is steel good or bad?
Startup advice overheard: you have too many hipsters, you won't scale
like that. Hire some fat guys who know C++.
We should have some ways of coupling programs like garden hose--screw in
another segment when it becomes necessary to massage data in another
way. This is the way of IO also.
Perhaps I'm a philistine about types but I've never found that model
particularly expressive.
The following data structures are a complete list for almost all
practical programs: array, linked list, hash table, binary tree.
Data dominates. If you've chosen the right data structures and organized
things well, the algorithms will almost always be self-evident. Data
structures, not algorithms, are central to programming.
Algorithms, or details of algorithms, can often be encoded compactly,
efficiently and expressively as data.  Code and data are the same,
or at least they can be. How else can you explain how a compiler works?
I think you have to open the objects and open your methods. I think that
this idea of hiding in layers of abstraction everything about the
details has, in fact, pretty much run its course now. I think the idea
that we can make these sorts of black box devices that we only know
about the shell of and have no knowledge of the internal workings of is
in fact a deep mistake. Because it turns out that in order to be able to
reason about how the system is actually working, we have to have
knowledge about what is inside the black box.
Well, I'm an old-fashioned guy. And I also happen to believe in history.
The lack of interest, the disdain for history is what makes computing
not-quite-a-field.
The Internet was done so well that most people think of it as a natural
resource like the Pacific Ocean, rather than something that was
man-made. When was the last time a technology with a scale like that was
so error-free? The Web, in comparison, is a joke. The Web was done by
amateurs.
Tell everyone your startup idea.  The idea thief has no passion.
People like Leibniz and Babbage and Lovelace and Turing and von Neumann
understood from the beginning that a computer wouldn't just be another
steam engine or toaster -- that, because of the property of universality
(whether or not they called it that), it's difficult even to talk about
computers without also talking about ourselves.
When your hammer is C++, everything begins to look like a thumb.
Beginner: "Threads are hard." Intermediate: "Don't fear multithreading."
Expert: "Threads are hard."
The only reason to have unit tests is to make sure that code that
already works doesn’t break. Writing tests first, or writing code to the
tests is ridiculous. If you write to the tests before the code, you
won’t even know what the edge cases are.
What children do well and adults forget about: constantly testing
boundaries.
Only ugly languages become popular. Python is the one exception.
If you believe "pragmatism" and "theory" are in opposition, you
understand neither.
Simplifying code is like diet and exercise: the result is healthy and
runs faster. Loop unrolling is plastic surgery: the result does not age
well and winds up making things _worse_ after a while. Don't optimize.
Simplify.
A way to handle design vs. implementation is to see the work as
components. Design is the boundaries, implementation is the contents.
When I was a young Erik, when I was a fundamentalist functional
programmer, I would say: "Of course, you're using mutable state, you
should not do that! Use Haskell or a real language and this won't
happen." But OTOH, now that I write code for a living, I kind of like
imperative programming. You can get stuff done, you know... The Real
World is imperative, so I think we need to embrace side effects.
Functional "programming" is a tool for thought. Imperative programming
is a tool for hackers.
Don't ever let anyone tell you that fork(2) is bad. Thirty years from
now, there will still be a fork(2) and a pipe(2) and a exec(2) and smart
people will still be using them to solve hard problems reliably and
predictably, just like they were thirty years ago.
These days I write code because (and when) I enjoy it and I think it'll
be useful to me or to my fellow hackers; if I decide I'd enjoy something
else more, I'll do that instead.  The new users can go and fuck
themselves.
First you learn the value of abstraction, then you learn the cost of
abstraction, then you're ready to engineer.
Our job is not just making things. Believe it or not, that's the easy
part. Our job is to figure out whether something should be made, how
it's made and convice someone, whether that's a client, a co-worker, a
manager or a VC, that we've made the right choice. That's design.
Dependency hygiene trumps code reuse.
Erlang is the culmination of twenty-five years of correct design
decisions in the language and platform. Whenever I've wondered about how
something in Erlang works, I have never disappointed in the answer. I
almost always leave with the impression that the designers did the
“right thing.” I suppose this is in contrast to Java, which does the
pedantic thing, Perl, which does the kludgy thing, Ruby, which has two
independent implementations of the wrong thing, and C, which doesn't do
anything.
It's pretty easy to spot that something is not flexible enough. Spotting
that it is too flexible can take years.
0.01: The factor of human beings who can program
0.001: The factor of human beings who can program concurrently
0.0001: The factor of human beings who can program distributively
Sometimes correctness trumps speed. Sometimes it is the other way around.
Idempotence is your key to network programming.
Protocol design is your key to network programming.
Sun RPC is usually not the solution. Corollary: HTTP requests neither.
In a distributed system, the important part is the messages. What
happens inside a given node is uninteresting. Especially what
programming language it is written in.
There is something very American about Feynman breaking into safes
during the Manhattan Project. It's hard to imagine the authorities
having a sense of humor about such things over in Germany at that time.
Maybe it's not a coincidence.
Hackers are unruly. That is the essence of hacking. And it is also the
essence of Americanness. It is no accident that Silicon Valley is in
America, and not France, or Germany, or England, or Japan. In those
countries, people color inside the lines.
We reject kings, presidents and voting. We believe in rough consensus
and running code.
I'd like to stand for simplicity in Programming Languages. The key thing
to remember is that a PL is a tool, and that the users of that tool need
to master it. So the average programmer using a language should know and
understand the entire language.
Make new developers do code reviews.
The key in making great and growable systems is much more to design how
its modules communicate rather than what their internal properties and
behaviors should be.
A wise person knows when to ignore his duties and improvise. Rules and
incentives may make things better in the short run, but they create a
downwards spiral that makes them worse in the long run.
Who is the CEO? The one bringing vision and culture.
The world moves forward on those who are dissidents. Because without
dissent there is no creativity.
- How long to develop this feature?
- How long does it take to catch a fish?
Google has found that the most innovative workers — also the “happiest,”
by its definition — are those who have a strong sense of mission about
their work and who also feel that they have much personal autonomy.
We are defined by what we make time to do, not by what we do when we
have time.
What I cannot create, I do not understand.
Nothing lasts. Nothing is finished. Nothing is perfect. Accepting the
world as imperfect, unfinished, and transient, and then going deeper and
celebrating that reality, is something not unlike freedom.
Not all products can be the hero. Some play supporting roles. Some have
bit parts. People need to understand your character’s role. It can’t
have too many dimensions. Choose wisely. Don’t confuse. Don’t be too
greedy.
In most languages, an array with n elements normally has those elements
numbered with subscripts ranging from 1 to n inclusive. Not so in C.
It appears to be a quite general principle that, whenever there is a
randomized way of doing something, then there is a nonrandomized way
that delivers better performance but requires more thought.
If you don't respect inherent complexity, you create accidental complexity.
You know what architecture is? It is the art of drawing lines.
It's not the consequence that makes a problem important, it is that you
have a reasonable attack.  Most great scientists know many
important problems. They have something between 10 and 20 important
problems for which they are looking for an attack. And when they see a
new idea come up, one hears them say ``Well that bears on this
problem.'' They drop all the other things and get after it.
The copyright industry is digging a grave for the Internet. They don't
take into account the public benefits of a free Internet. The problem
is that old people are running the companies. They know how you made
money before and they don't want to change. They're like the Amish:
they don't want electricity, they know how to make do without
electricity.
I think software is getting worse and worse and worse with time. It's
not that we cannot do amazing things with computers, we can! But when
they don't work, we don't understand why they don't work. In the past,
when you had a program that didn't work, you can look at it. Now, you
ask Google.
Sometimes, changing one line of legacy code is as difficult as
rewriting the entire thing. But management doesn't think that.
The notion that you can have data consistent in two different places
break the laws of physics (causality). Despite this fact, we build
systems with 2PC and forget about it.
The key to a design methodology is being able to split computations
into completely independent parts. If you manage to solve your problem
by dividing it into independent parts, you can get both fault tolerance
and scalability. I don't agree  that you can either get fault
tolerance or scalability. You can only get both or none of them.
When I learnt programming, everybody said we should have defensive
programming, we should check our arguments all the time. Defensive
programming in C is only necessary because you have a single thread of
computation. If you have a sequential language and it crashes, you've
lost everything.
The process approach to fault isolation advocates that the process
software be fail-fast. It should either function correctly or it should
detect the fault, signal failure and stop operating.
I really disagree with Postel's principle.  You shouldn't be
lenient with your inputs. If your inputs are completely cracked you
should just stop immediatly.
History and debugging are both about uncovering causality from precedence.
If you think that time is sequence, you lose half of the game.
There are two opposite ways to build systems: hack them, test them, and
hope they work, or think about them and use well-defined tools.
Anything added dilutes everything else.
I get grumpy and mad and frustrated reading poor quality patches all
the time.  If you didn't get angry and mad and frustrated, that
means you don't care about the end result, and are doing something
wrong.
To me, the fundamental outcome of research is understanding, and the
fundamental outcome of engineering is a product.
Don’t ever make the mistake of thinking that you can design something
better than what you get from ruthless massively parallel
trial-and-error with a feedback cycle. That’s giving your intelligence
much too much credit.
Saying "the brain is not a computer" is akin to saying "applesauce
is not an apple." Technically that statement is true, but you can make
applesauce from an apple. Perhaps more to the point, it is like saying
"computers are not word processors". A computer can become a brain if
it is running brain software.
We each need a leap of faith as to what and who is conscious, and who
and what we are as conscious beings. Otherwise we could not get up in
the morning. But we should be honest about the fundamental need for a
leap of faith in this matter and self-reflective as to what our own
particular leap involves.
There's a reason computer history is a hobby of mine, I want to know
_why_ we do things.
What moved a lot of engineers into product is frustration with the
silliness.  I was really excited because I thought agile was a
revolution by the developers to stop the insanity. Unfortunately, I
think the business types outsmarted all of us. They basically pushed a
spec into the basement and said: "You know, you can do your standups,
you can have fun, do whatever you want! But here's your roadmap."
And it is true that most agile teams move a little faster, but the
results don't get better.
After folding my first company (at 25), I did a retrospective and
counted 32 different projects — most of them, whole new products or
product variations — I’d started (and almost never completed) in the
prior year. I realized this may have had something to do with my
failure.
When it comes to writing code, the number one most important skill is
how to keep a tangle of features from collapsing under the weight of
its own complexity.
OH: "Yes, it's flexible. Like rope."
Merely adding features does not make it easier for users to do things,
it just makes the manual thicker.
First you learn the value of abstraction, then you learn the cost of
abstraction, then you're ready to engineer.
Originally I was going to program twttr in Python, C, & Ocaml. But, I
got @florian who was a core contributor to Ruby on Rails.
Humans fundamentally understand atomicity.  They understand that
the state of the world is always changing and they deal with it.
People who are not technical are smarter than we give them credit for.
They understand the nature of the world is that there are not as many
guarantees in a lot of things that they do, and they are forgiving of
certain kinds of errors.
How many of you wouldn't want to hire someone on their team if they
didn't know the framework magic already?
I have witnessed numerous occasions where an inordinately expensive
query was made 8-times faster by parallelizing... where the trivial
refactoring into a slimmed down algorithm with proper data structures
would have speed the code up by 100-fold. Parallelizing a piggy piece
of code to make it faster merely uses more of the machine to get the
same job done, and will negatively impact power, resource management,
and utilization.
An escalator can never break: it can only become stairs. You should
never see an Escalator Temporarily Out Of Order sign, just Escalator
Temporarily Stairs. Sorry for the convenience.
Software is a gas. It expands to fill its container.
Hardware is like milk: you want the freshest possible. Software is like
wine, it becomes better with age.
Design is a funny word. Some people think design means how it looks.
But of course, if you dig deeper, it's really how it works.
N'attendre de l’État que deux choses : liberté, sécurité, et bien voir
qu'on ne saurait, au risque de les perdre toutes deux, en demander une
troisième.
Does comment on taste belong in a discussion of history? I think so.
Unix was born of a taste for achieving big power by small means rather
than by unbounded accumulation of facilities. But evolution, including
the evolution of Unix, does not work that way. An interesting question
is how the corrective of taste manages ever to recenter the exuberance
of evolution. The birth of Unix shows it can happen. When will it
happen again?
That's what a professional does: a professional takes the risk on what
they know must be done.
Probably nothing has done so much harm to the liberal cause as the
wooden insistence of some liberals on certain rules of thumb, above all
the principle of laissez-faire capitalism.
If you build someone a fire, you'll keep them warm for a night. If you
set someone on fire, you'll keep them warm for the rest of their life.
The problem, Bernard, is that what you and I do is so complicated. We
practice witchcraft.  William of Occam was a 13th century monk. He
can't help us now, Bernard. He would have burned us at the stake.
Object-oriented programming offers a sustainable way to write spaghetti
code. It lets you accrete programs as a series of patches. Large
organizations always tend to develop software this way, and I expect
this to be as true in a hundred years as it is today.
The most profound technologies are those that disappear. They weave
themselves into the fabric of everyday life until they are
indistinguishable from it.
I'm more inclined to work with someone who wants to build a company of
the right size than with someone who wants to build the right thing.
Why do people keep thinking that having awesome support is the best
option? Not needing support in the first place is the best option.
Having support doesn't solve the time spent, blocking time wasted, etc.
That's time I can't get back. I want your thing to just work.
Universal step 1 of becoming an awesome <insert profession>: care.
The best argument against democracy is a five-minute conversation with
the average voter.
Contrary to popular belief, Unix is user friendly. It just happens to
be very selective about who it decides to make friends with.
A firewall is the simplest, most effective means to secure a database.
Sounds complicated, but it’s so easy a government agent could do it.
The older I get, the less I care about making tech decisions right and
the more I care about retaining the ability to change a wrong one.
Complex algorithms are used only if their complexity can be localized.
Modern invention has been a great leveller. A machine may operate far
more quickly than a political or economic measure to abolish privilege
and wipe out the distinctions of class or finance.
The key to performance is elegance, not battalions of special cases.
There is no compression algorithm for experience.
The meaning of my work is the motivation that is of the purest – money.
What I did for Playboy is very good and your payment is equal to the
task.
Machine learning is like money laundering for bias.
Anyone who has ever debugged programs in both compiled and interpreted
languages e.g., C versus Java knows they are miles apart. A good VM
makes the language safe, in the sense that errors can always be
understood in terms of the language itself, not in term of the
underlying machine (e.g., segmentation fault).
This is a two-way street. The implementation has a huge impact on the
design of the software: we should not design what we cannot implement
efficiently.
There is a difference between designing in a way that allows for future
change and attempting to predict the future.  Code should be
designed based on what you know now, not on what you think will happen
in the future.
Nearly all decisions in software design reduce entirely to measuring
the future value of a change versus its effort of maintenance.  It
is more important to reduce the effort of maintenance than it is to
reduce the effort of implementation.
Comments should explain why the code is doing something, not what it is
doing.
When presented with complexity, ask: "What problem are you trying to
solve?"
My rule of thumb was when a problem was occurring at least 50 times a
day, it was time to solve it more holistically.  If you don’t
solve problems manually first, you could lose crucial insights into
what’s causing a problem and why.
From Ruby to Mongo, MySQL to Node successful open source is usually the
fun and easy thing to get started with.
Make sure you know what's inside the box before trying to think outside
of it.
We think awful code is written by awful devs. But in reality, it's
written by reasonable devs in awful circumstances.
The benefit of dependencies is inversely proportional to the amount of
effort spent on a software project.
The work of engineers used to be about taking small parts that they
understood entirely and using simple techniques to compose them into
larger things that do what they want. But programming now isn't so much
like that. Nowadays you muck around with incomprehensible or
nonexistent man pages for software you don't know who wrote. You have
to do basic science on your libraries to see how they work, trying out
different inputs and seeing how the code reacts. This is a
fundamentally different job.
Work in complex systems is bounded by three types of constraints:
economic, workload and safety.
If you're going to make something cheaper, you're going to make people
work harder or less safely.
The only thing you learn from releasing a mediocre product early is
that people don't like mediocre products.
Core memory wiped out competing technologies (Williams tube, mercury
delay line, etc) almost instantly and ruled for over twent years. Yet
late in his life Forrester told me that the Whirlwind-connected
invention he was most proud of was marginal testing: running the
voltage up and down once a day to cause shaky vacuum tubes to fail
during scheduled maintenance rather than randomly during operation. And
indeed Wirlwind racked up a notable record of reliability.
Would you rather fight one 800lb gorilla or 800 1lb gorillas that
trust you as their parent? is the interview question that determines
whether you're an IC or an engineering manager.
On the NPM website, they say: "What can you make with 700,000 building
blocks?" and to me it's like: "What can you make with 10,000 kitchens?"
Don't give your users what they ask for, give them what they want.
The world would be a better place if more engineers, like me, hated
technology. The stuff I design, if I'm successful, nobody will ever
notice. Things will just work, and be self-managing.
The first step towards the failure is trying.
People die climbing mountains.
Those who doubt your ability probably have a valid reason.
The best things in life are actually really expensive.
Dream only to escape the miserable reality of your life.
It probably will get worse.
You can be replaced.
Don't cry because it's over, smile because if you don't everyone will ask you what's wrong.
If at first you don't succeed, give up and try something else.
Don't worry about what other people are going to think of you. You know you're a cock.
Always believe that something wonderful will probably never happen.
Life is not a fairly tale. If you lose your shoe at midnight, you're drunk.
You're born, you work, you die.
It's always darkest.
If your coffee order is more than four words you are part of the problem.
It's a beautiful day to shut the fuck up.
Working out is a great way to make your slow march towards death a little more attractive.
You're only here because your parents had sex.
Reduce your carbon footprint by staying in your home and not coming near me.
A good thing to do with your opinion is stick it up your ass.
Your favorite exercise is crying.
The first thing I do every morning is regret waking up.
Life is stupid and hard.
Fuck winter.
Literally no one cares.
Any restaurant can be drive-thru if you don't care about your car.
You don't deserve full size candy.
Nobody gives a shit what you ate for lunch.
Relationships are like fine wine: they're expensive and eventually you just end up with a headache.
Please don't talk to me, I hate you.
It's never too late to give up.